---
layout: post
title: Preparing SQL Queries
date: '2008-07-02T10:35:00-07:00'
tags:
- php
- sql
tumblr_url: http://seanmonstar.com/post/706950211/preparing-sql-queries
---
<p>With web applications becoming more prevalent, and new developers showing up to fill the demand, security for web applications is increasingly important.  Some applications have very special, very private data that should be only accessible to the specific user.  Other, less “important” applications that don’t collect a lot of personal data, still have a need for security.  With simple <em>SQL Injection</em>, your up and coming social media application could have it’s whole database wiped, just for kicks.</p>
<p>Thankfully, there’s a rather simple procedure to prevent the majority of malicious code injections by <em>preparing your SQL queries</em> before sending them into your database.  Let’s take a look at how to do so with <em>CodeIgniter</em>, but before that, how to do so using only the <em>PHP’s native PDO interface</em>.</p>
<h5>SQL Injections</h5>
<p>What is an SQL Injection?  It’s helpful to know what this is so we can better understand what we’re defending against.  One example is retrieving all user information:</p>
<pre>SELECT * FROM users WHERE name = '.$userName.';</pre>
<p>In the form field where we supply $userName, if we type <em>x’ OR ‘1′=’1</em>, then the query gets turned into:</p>
<pre>SELECT * FROM users WHERE name = 'x' OR '1'='1';</pre>
<p>Name may never equal x, but using <em>OR</em>, with an expression that is always true (1 = 1), we just recieved every row in the table.</p>
<p>One other example shows how instead of stealing data, a hacker could blow away your database.  Typing <em>x’;DROP TABLE users; SELECT * FROM users WHERE name=’x</em></p>
<pre>SELECT * FROM users WHERE name = 'x';DROP TABLE users; SELECT * FROM users WHRE name='x';</pre>
<p>With a little guessing that the table might be called users, we just set a 3-part chained query.  The first returns nothing, cause no name is x, the second deletes all rows from users, and the third returns nothing, cause there’s no more users, but deals with the ending single quote (’).</p>
<p>Yikes! Just a little guess work, and our literally composed query can be easily manipulated to destroy an application or leak information.  Here’s a <a href="http://www.unixwiz.net/techtips/sql-injection.html">walkthrough case study of an anonomized injection</a> to see how a hacker might compromise your application.  Now on to protecting ourselves from malicious injection.</p>
<h4>Native PDO Interface</h4>
<h5>The Model</h5>
<p>Let’s make a very basic Model class that will interact with our database. Note, this doesn’t include connecting to the database.  I assume you know how to do so.</p>
<pre>&lt;?php
class Model extends PDO
{
	public static function query($query, $args) {
		$statement = $this-&gt;prepare($query);
		foreach($args as $num =&gt; $value) {
			$argNum = $num + 1;
			if(is_null($value))
				$statement-&gt;bindValue($argNum, $value, PDO::PARAM_NULL);
			else if(is_bool($value))
				$statement-&gt;bindValue($argNum, $value, PDO::PARAM_BOOL);
			else if(is_int($value))
				$statement-&gt;bindValue($argNum, $value, PDO::PARAM_INT);
			else if(is_string($value))
				$statement-&gt;bindValue($argNum, $value, PDO::PARAM_STR);
			else
				$statement-&gt;bindValue($argNum, $value);
		}
		$statement-&gt;execute();
		return $statement-&gt;fetchAll();
	}
}?&gt;</pre>
<p>Cool beans.  Now we can structure a query in our controller, and remembering to include this class at the top, we can make a safe query:</p>
<pre>&lt;?php
include('Model.class.php');
$id = 1;
$result = Model::query("SELECT * FROM table WHERE id=?",array($id);?&gt;</pre>
<p>What we did here was contructed the query, but left out the values and substituted in question marks.  We then passed the values as a seperate parameter.  So what happens?</p>
<h5>PDO::prepare() and PDO::bindValue()</h5>
<p>First, your query is prepared using the prepare() function extended from PDO.  This prepares your statement to have the values passed into it wherever there were question marks.</p>
<p>Next, for each value, the data type is checked, and then bindValue() from PDO is called, and checks that it is the proper data type.  At this time, it will also place the proper single quotes, insuring our quotes aren’t manipulated.</p>
<p>Finally, PDO::execute() sends the bound query, and PDO::fetchAll() returns the rows of data from the query.  You can read up more about the <a href="http://php.net/">PDO interface at php.net</a>.</p>
<h4>Soul Binding with CodeIgniter</h4>
<p>I personally prefer to <a href="http://../contact">develop</a> using CodeIgniter, and the above functionality is already written for me.  Let’s see how to very simply accomplish the same in this <a href="http://codeigniter.com/">wonderful framework</a>.</p>
<pre>$this-&gt;db-&gt;query("SELECT * FROM table WHERE status = ? AND author = ?", array('Published', 'Sean'));</pre>
<p>Ah, so very simple.  Well, just as simple as above.  But this is the CodeIgniter way.</p>
<h5>Other Tips</h5>
<p>A few other things that will <em>help prevent guesswork on your database</em>:</p>
<ol><li>Make your column names with prefixs, or a personal touch to keep them out of the ordinary.</li>
<li>Same applies to your tables, give them specialized names like “sean_blog_users” instead of simply “users”.</li>
</ol><p><small>Employing these techniques will by no means make your application hacker-proof.  There’s no such thing.  Anyone can break security as long as they’re determined enough.</small></p>
