---
layout: post
title: ! 'MVC in MooTools: Models'
date: '2010-08-25T08:00:00-07:00'
tags:
- javascript
- mootools
- mvc
- monstars.js
tumblr_url: http://seanmonstar.com/post/1009142033/mvc-in-mootools-models
---
<p>It&rsquo;s really bugged me when writing large JavaScript applications, organization of code never really seems to be considered. We use frameworks for all the server-side stuff we do, but everyone seems content writing JavaScript in <a href="http://jquery.com">one big mess</a>.</p>

<p>Granted, that&rsquo;s why I was attracted to MooTools in the first place: the idea of organizing your code is built into the framework. If you don&rsquo;t predominantly write classes with MooTools, you might as well be <a href="http://jqueryvsmootools.com">writing jQuery</a>. But even with classes, in a JavaScript application<sup id="fnref:p1009142033-1"><a href="#fn:p1009142033-1" rel="footnote">1</a></sup> you write a lot of code that works with those classes and fiddles with the DOM. It can get to be a real <em>mess</em>.</p>

<p>A year ago, I got fed up with it. I was also interested in Adobe AIR at the time, and liked the idea of being able to copy over as much of my code as possible to make an AIR version of an application. Hopefully, the only changes would be the way data was stored and received. I feel pretty good when using the MVC paradigm on the server-side, and I felt it made sense in the browser as well. So I started a <a href="http://github.com/seanmonstar/monstars.js">MooTools MVC framework</a>.</p>

<h3>Models</h3>

<p>I started with making various sub-classes of Model<sup id="fnref:p1009142033-2"><a href="#fn:p1009142033-2" rel="footnote">2</a></sup> that interacted with specific data storage concepts. In Adobe AIR, a SQLite database would likely be used. In the browser, you&rsquo;d likely have you&rsquo;re data stored on the server, and need to access it via ajax. I wanted to be able to have the same model class, and just change its subclass based on need. Certainly, the <code>Model.SQL</code> could be used in newer browsers, as well, if you wished.</p>

<p>It didn&rsquo;t take look for me to give up for the time being on AIR, but I still felt that the organization that such a framework provided was beneficial. Therefore, I spent more time on <code>Model.Ajax</code> and <code>Model.Browser</code>, since most of my use of the framework has been for the browser. <code>Model.Browser</code> uses a combination of localStorage, userData, and cookies, depending on support, to allow a web application to function entirely on the client side. I did much of this just to allow myself to work out an example application, without needing a back-end.</p>

<p><code>Model.Ajax</code> is what I use the most, now. Let me show you an example model:</p>

<pre><code>var Task = new Class({

    Extends: Model.Ajax,

    fields: {
        id: Model.Fields.AutoField({ write: false }),
        title: Model.Fields.TextField(),
        created_at: Model.Fields.DateField(),
        tags: Model.Fields.ManyToManyField(Tag)
        is_done: Model.Fields.BooleanField({ default: true })
    }

});
</code></pre>

<p>By extending <code>Model.Ajax</code>, <code>Task</code> will make some default assumptions about the back-end API. For instance, <code>Task.find</code> will call <code>/tasks/find</code>, <code>Task.get(5)</code> will call <code>/tasks/5</code>, and <code>myTask.save()</code> will call <code>/tasks/insert</code> or <code>/tasks/5/update</code> depending on if it&rsquo;s new or not. And of course, because of the asynchronous nature of all these function calls, a callback can be passed, which will receive the instances as it&rsquo;s only parameter upon completion. Such as:</p>

<pre><code>Task.get('123', function(task) {
    console.log(task); //the returned data, cast as an instance of Task already
});
</code></pre>

<p>A model also declares its fields, so that every time a new Task is made with a hash of properties, it only extracts the ones it cares about, and converts them to the proper type if it can. Specifically, I&rsquo;ve set <code>id</code> to read only, since I don&rsquo;t want something accidentally changing the <code>id</code> of a task and sending it.</p>

<p>An instance of a <code>Model</code> can access it&rsquo;s properties through getter and setter functions. These are similar to the <a href="http://mootools.net/blog/2010/06/10/setting-up-elements/">Element getter and setters</a>, and they allow each individual field type to cast to the proper type, or return a default. For example:</p>

<pre><code>var myTask = new Task;
myTask.set('is_done', 'true');
console.log(myTask.get('is_done')); //will return the boolean true, not the string.
</code></pre>

<p>This also allows Fields that provide relationships to other models cast ids to instances and back again. <code>Task.tags</code> will store an array of tag ids internally, and submit those to the server upon a save. But if you <code>get</code> the tags, the <code>ManyToManyField</code> will convert them into the existing <code>Tag</code> instances.</p>

<p>The point of using Models in this framework is to have a single location that is responsible for abstracting data retrieval<sup id="fnref:p1009142033-3"><a href="#fn:p1009142033-3" rel="footnote">3</a></sup>, and providing a central place to handle any data conversion. You shouldn&rsquo;t have any Ajax requests or data validation any where else in your application.</p>

<div class="footnotes">
<hr><ol><li id="fn:p1009142033-1">
<p>From here on out, my use of a JavaScript application is one where a large amount of it is written in JavaScript. Sure, your requests still need to interact with a server-side technology, but on the client side, most of the application functions without page refreshes. <a href="#fnref:p1009142033-1" rev="footnote">↩</a></p>
</li>

<li id="fn:p1009142033-2">
<p>The assumption is made that you know what MVC is. If not, <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">read up</a>. <a href="#fnref:p1009142033-2" rev="footnote">↩</a></p>
</li>

<li id="fn:p1009142033-3">
<p>Whether the Model or the Controller should do the ajax requests has been <a href="http://www.alistapart.com/articles/javascript-mvc/">argued</a> both ways when used in a JavaScript MVC framework, . Since the primary reason for a Model is to abstract the data storage system, it makes sense to me that only the Model should know if it needs to access a web server via ajax, or use localStorage, or use SQLite. <a href="#fnref:p1009142033-3" rev="footnote">↩</a></p>
</li>

</ol></div>
