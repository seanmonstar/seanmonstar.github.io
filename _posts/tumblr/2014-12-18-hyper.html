---
layout: post
title: hyper
date: '2014-12-18T11:30:00-08:00'
tags:
- rust-lang
- hyper
- http
- rust
- mozilla
- planet
tumblr_url: http://seanmonstar.com/post/105541782562/hyper
---
<p><a href="https://rust-lang.org">Rust</a> is a shiny new systems language that the lovely folks at Mozilla are building. It focuses on complete memory-safety, and being very fast. Its speed is equivalent to C++ code, but you don&rsquo;t have to manage pointers and the like; the language does that for you. It also catches a lot of irritating runtime errors at compile time, thanks to its fantastic type system. That should mean less crashes.</p>

<p>All of this sounds fantastic, let&rsquo;s use it to make server software! It will be faster, and crash less. One speed bump: there&rsquo;s no real rust http library.</p>

<h3>rust-http and Teepee</h3>

<p>There were 2 prior attempts at HTTP libraries, but the former (<a href="https://github.com/chris-morgan/rust-http">rust-http</a>) has been ditched by its creator, and isn&rsquo;t very &ldquo;rust-like&rdquo;. The latter, <a href="http://teepee.rs">Teepee</a>, started in an excellent direction, but life has gotten in the way for the author.<sup id="fnref:p105541782562-1"><a href="#fn:p105541782562-1" rel="footnote">1</a></sup></p>

<p>For the client-side only, there exists <a href="https://github.com/carllerche/curl-rust">curl-rust</a>, which are just bindings to libcurl. Ideally, we&rsquo;d like to have the all of the code written in Rust, so we don&rsquo;t have to trust that the curl developers have written perfectly memory-safe code.</p>

<p>So I started a new one. I called it <a href="https://github.com/hyperium/hyper">hyper</a>, cause, y'know, <em>hyper</em>-text transfer protocol.</p>

<h3>embracing types</h3>

<p>The type system in Rust is quite phenomenal. Wait, what? Did I just say that? Huh, I guess I did. I know, I know, we hate wrestling with type systems. I can&rsquo;t touch any Java code without cursing the type system. Thanks to Rust&rsquo;s type inference, though, it&rsquo;s not irritating at all.</p>

<p>In contrast, I&rsquo;ve gotten tired of stringly-typed languages; chief among them is JavaScript. <strong>Everything</strong> is a string. Even property lookups. <code>document.onlood = onload;</code> is perfectly valid, since it just treats <code>onlood</code> as a string. You know a big problem with strings? Typos. If you write JavaScript, you <strong>will</strong> write typos that aren&rsquo;t caught until your code is in production, and you see that an event handler is never triggered, or <code>undefined is not a function</code>.</p>

<p>I&rsquo;m done with that. But if you still want to be able to use strings in your rust code, you certainly can. Just use something else besides hyper.</p>

<p>Now then, how about some examples. It&rsquo;s most noticeable when using headers. In JavaScript, you&rsquo;d likely do something like:</p>

<pre><code>req.headers['content-type'] = 'application/json';
</code></pre>

<p>Here&rsquo;s how to do the same using hyper:</p>

<pre><code>req.headers.set(ContentType(Mime(Application, Json, vec![])));
</code></pre>

<p>Huh, interesting. Looks like more code. Yes, yes it is. But it&rsquo;s also code that has been checked by the compiler. It has made sure there are no typos. It also has made sure you didn&rsquo;t try to see the wrong format to a header. To get the header back out:</p>

<pre><code>match req.headers.get() {
    Some(&amp;ContentType(Mime(Application, Json, _))) =&gt; "it's json!",
    Some(&amp;ContentType(Mime(top, sub, _))) =&gt; "we can handle top and sub",
    None =&gt; "le sad"
}
</code></pre>

<p>Here&rsquo;s an example that makes sure the format is correct:</p>

<pre><code>req.headers.set(Date(time::utc_now()));
// ...
match req.headers.get() {
    Some(&amp;Date(ref tm)) =&gt; {
        // tm is a Tm instance, without you dealing with
        // the various allowed formats in the HTTP spec.
    }
    // ...
}
</code></pre>

<p>Yea, yea, there is a stringly-typed API, for those rare cases you might need it, but it&rsquo;s purposefully not easy to use. You shouldn&rsquo;t use it. Maybe you think of a reason you might maybe have a good reason; no you don&rsquo;t. Don&rsquo;t use it. Let the compiler check for errors <em>before</em> you hit production.</p>

<p>Let&rsquo;s look at status codes. Can you tell me what exactly this response means, without looking it up?</p>

<pre><code>res.status = 307;
</code></pre>

<p>How about this instead:</p>

<pre><code>res.status = StatusCode::MovedTemporarily;
</code></pre>

<p>Clearly better. You&rsquo;ve seen code like this:</p>

<pre><code>if res.status / 100 == 4 {}
</code></pre>

<p>What if we could make it better:</p>

<pre><code>if res.status.is_client_error() {}
</code></pre>

<h3>Message WriteStatus</h3>

<p>I&rsquo;ve been bitten by this before, I can only bet you have also: trying to write headers after they&rsquo;ve already been sent. Hyper makes this a compile-time check. If you have a <code>Request&lt;Fresh&gt;</code>, then there exists <code>header_mut()</code> methods to get a mutable reference to the headers, so you can add some. You can&rsquo;t accidently write to a <code>Request&lt;Fresh&gt;</code>, since it doesn&rsquo;t implement <code>Writer</code>. When you are ready to start writing the body, you must specifically convert to a <code>Request&lt;Streaming&gt;</code> using <code>req.start()</code>.</p>

<p>Likewise, a <code>Request&lt;Streaming&gt;</code> does not contain a <code>headers_mut()</code> accessor. You cannot change the headers once streaming has started. You can still inspect them, if that&rsquo;s needed, but no setting! The compiler will make sure you don&rsquo;t have that mistake in your code.</p>

<h3>NetworkStreams</h3>

<p>Both the <code>Server</code> and the <code>Client</code> are generic over <code>NetworkStream</code>s. The default is to use <code>HttpStream</code>, which can handle HTTP over TCP, and HTTPS using openssl. This design also allows something like Servo to implement a <code>ServoStream</code> or something, which could handle HTTPS using NSS instead.</p>

<h3>Goals</h3>

<p>These are some high level goals for the library, so you can see the direction:</p>

<ul><li><strong>Be fast!</strong>

<ul><li>The benchmarks preach that we&rsquo;re already faster than both rust-http and libcurl. And we all know science doesn&rsquo;t lie.</li>
</ul></li>
<li>Embrace types.

<ul><li>See the above post for how we&rsquo;re doing this.</li>
</ul></li>
<li>Provide an excellent http server library for rust webdev.

<ul><li>Currently used by Iron, Rustless, Sserve, and <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=hyper+extension%3Atoml&amp;type=Code&amp;ref=advsearch&amp;l=">others</a> &hellip;</li>
</ul></li>
<li>Provide an excellent http client that can be used in place of curl.

<ul><li>It has <a href="https://github.com/servo/servo/commit/6bd9bf979bcfa96ea14e666b59eab01a6d6c373e">landed in Servo</a>!</li>
</ul></li>
</ul><p>The first step for hyper was get the streams and types working correctly and quickly. With the factory working underneath, it allows others to write specific implementations without re-doing all of HTTP, such as implementing the XHR<sup id="fnref:p105541782562-2"><a href="#fn:p105541782562-2" rel="footnote">2</a></sup> spec in Servo. Work now has been on providing ergonomic <a href="http://hyperium.github.io/hyper/hyper/client/index.html"><code>Client</code></a> and <a href="http://hyperium.github.io/hyper/hyper/server/index.html"><code>Server</code></a> implementations.</p>

<p>It looks increasingly likely that <a href="https://github.com/hyperium/hyper">hyper</a> will be available to use on <a href="http://blog.rust-lang.org/2014/12/12/1.0-Timeline.html">Rust-1.0-day</a>.<sup id="fnref:p105541782562-3"><a href="#fn:p105541782562-3" rel="footnote">3</a></sup><strong>There will be an HTTP library for Rust 1.0!</strong></p>

<div class="footnotes">
<hr><ol><li id="fn:p105541782562-1">
<p>Teepee provided excellent inspiration in some of the design, and all that credit should go to its creator, Chris Morgan. He&rsquo;s continued to provide insight in the development of hyper, so &lt;3! <a href="#fnref:p105541782562-1" rev="footnote">↩</a></p>
</li>

<li id="fn:p105541782562-2">
<p>Yes, it differs. It&rsquo;s been a delight to see that developers are never content with an <a href="http://xkcd.com/927/">existing spec</a>. <a href="#fnref:p105541782562-2" rev="footnote">↩</a></p>
</li>

<li id="fn:p105541782562-3">
<p>Rust 1.0 will ship with only <code>stable</code> APIs and features. Some features will only be accessible by the nightlies, and not likely to be stabilized for 1.0. Hyper doesn&rsquo;t depend on these, and so should be compilable using <code>rustc v1.0.0</code>. <a href="#fnref:p105541782562-3" rev="footnote">↩</a></p>
</li>

</ol></div>
