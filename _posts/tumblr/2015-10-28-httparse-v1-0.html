---
layout: post
title: httparse v1.0
date: '2015-10-28T14:13:32-04:00'
tags:
- http
- hyper
- httparse
- rust
- rust-lang
- planet
tumblr_url: https://seanmonstar.com/post/132094366797/httparse-v1-0
---
<p>The <a href="https://crates.io/crates/httparse">HTTP/1.1 parser</a> used in <a href="http://hyper.rs">hyper</a>, hasn&rsquo;t really seen any API changes since it was designed, and in the spirit of moving &ldquo;stable&rdquo; things to 1.0, I bumped that magical number up.</p>

<h3>httparse?</h3>

<p>If you mainly use hyper (or a framework on top, like iron, nickel, rustless, etc), then this really shouldn&rsquo;t affect you at all. It&rsquo;s just the parsing logic for the HTTP/1.1 spec in a standalone crate.</p>

<p>If you work on some other project that requires parsing HTTP1<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, then you may want to try using <a href="https://crates.io/crates/httparse">httparse</a>. Why?</p>

<h3>It&rsquo;s fast.</h3>

<p>First, some buzz words. It&rsquo;s stateless. It&rsquo;s zero-copy. It performs zero allocations. It&rsquo;s design piggybacks on the design of <a href="https://github.com/h2o/picohttpparser">picohttpparser</a>, which does the same.</p>

<ul>
<li>Stateless: Keeping state means branches. Branches slow down individual parsing attempts. Instead, state of a socket can and should be handled outside of the parser itself. As the socket receives more data, you can try to parse again</li>
<li>Zero-copy</li>
<li>Zero allocations</li>
</ul>

<h3>It&rsquo;s safe.</h3>

<p>To be fast, and yet safe, an <code>Iterator</code> is used to prevent unnecessary bounds checks. That implementation is encapsulated in an inner private module, so the safety is easier to audit, and a safe API is exposed from the module, so the main API must use the iterator safely.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>

<h3>Coming 1.1 and 1.2</h3>

<p>There&rsquo;s two lower hanging fruit that could provide noticeable speed improvements: branch predictions, and SIMD. There&rsquo;s an <a href="https://github.com/rust-lang/rfcs/blob/master/text/1131-likely-intrinsic.md">accepted Rust RFC for adding a <code>likely</code> intrinsic</a> that gives us branch prediction, but its <a href="https://github.com/rust-lang/rust/issues/26179">implementation</a> needs an extra push to get in.</p>

<p>There&rsquo;s the <a href="https://crates.io/crates/simd">simd crate</a>, with only 2 things preventing it from speeding up httparse: its using an unstable feature or three, and SSE4 support is needed to get <code>_mm_cmpestri</code>, which would provide the biggest boost.</p>

<p>Or maybe both of these will be available at the same time, and they both can be added in httparse 1.1.</p>

<div class="footnotes" role="doc-endnotes">
<hr>
<ol>

<li id="fn:1" role="doc-endnote">
<p>Building your own HTTP library? Get out of here! &lt;3 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">↩︎</a></p>
</li>

<li id="fn:2" role="doc-endnote">
<p>Don&rsquo;t look at the <code>next_8</code> API. It&rsquo;s wonky. I wanted a safe way to get 8 bytes at a time, and also be able to safely tell the <code>Iterator</code> how far into those 8 bytes I actually got. It&rsquo;d probably be better to make that a closure instead, like <code>bytes.with_8(|eight| check!(eight))</code>. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">↩︎</a></p>
</li>

</ol>
</div>
