---
layout: post
title: HTTP upgrades with hyper
date: '2018-04-02T17:34:53-04:00'
tags:
- hyper
- rust
- rust-lang
tumblr_url: https://seanmonstar.com/post/172531530657/http-upgrades-with-hyper
---
<p>The <a href="https://github.com/hyperium/hyper/releases/tag/v0.11.23">newest release</a> of <a href="https://hyper.rs">hyper</a> includes some <strong>lower-level connection APIs</strong> for both the <a href="server::conn">server</a> and <a href="client::conn">client</a>.</p>

<p>These allow finer-grained control of exactly what is happening during an HTTP request, and the higher-level APIs already provided by hyper use these internally. However, the point is that if control is what you need, these APIs allow you to build your own abstractions on top, such as a different implementation of connection pooling than the one provided in <code>hyper::Client</code>. Some examples of the exact control this gives include:</p>

<ul>
<li>The exact <code>Uri</code> to write, such as using the origin-form or absolute-form when talking to a proxy.</li>
<li>The <code>Host</code> header.</li>
<li>When to shutdown the connection (or to pool them).</li>
<li>Take over the underlying IO transport again.</li>
</ul>

<h3>A Websocket Upgrade</h3>

<p>Notably, this allows using hyper send and receive <strong>HTTP upgrade requests</strong>. The most popular of these is Websockets. Here&rsquo;s an example of how you could get Websockets working with hyper, broken up into 3 parts:</p>

<p>The first step is to create some IO transport, such as connecting a <code>TcpStream</code>, and then preparing an HTTP handshake.</p>

<pre><code class="rust">TcpStream::connect(&amp;addr, &amp;handle)
    .and_then(|tcp| {
        // preparing HTTP over this socket
        hyper::client::conn::handshake(tcp)
    })
</code></pre>

<p>The above is a <code>Future</code> that fulfills with a <code>SendRequest</code> and <code>Connection</code>. The <code>SendRequest</code> is used to, surprise, send requests over the connection. The <code>Connection</code> is a <code>Future</code> that should be polled continually to make progress on the HTTP state machine.</p>

<p>Once you have those, you could send a specific upgrade request, and prepare to get a <code>101 Switching Protocols</code> response.</p>

<pre><code class="rust">.and_then(|(mut client, conn)| {
    let req = Request::new(Method::Get, "/chat".parse().unwrap());
    // should set relevant Upgrade headers

    let res = client.send_request(req)
        .inspect(|res| {
            // Probably shouldn't actually use asserts
            assert_eq!(res.status(), StatusCode::SwitchingProtocols);
            assert_eq!(
                res.headers().get_raw("Upgrade").unwrap(),
                "websocket"
            );
        })

    // Put in an Option so poll_fn can return it later
    let mut conn = Some(conn);
    let until_upgrade = future::poll_fn(move || {
        try_ready!(conn
            .as_mut()
            .unwrap()
            // Poll until HTTP is complete, but don't shutdown socket
            .poll_without_shutdown()
        );
        Ok(Async::Ready(conn.take().unwrap())
    });

    res.join(until_upgrade)
})
</code></pre>

<p>The above joins on a future of the <code>Response</code>, and a custom mini future that polls the <code>Connection</code> without trigger a full shutdown. The <code>Connection</code> will process its state until it notices that a 101 response was received (or the connection was closed normally (or with an error)). However, it <em>won&rsquo;t</em> call <code>shutdown</code> on the provided IO transport. This is key if you plan to continue using the transport after HTTP is completed.</p>

<p>Next, the connection can be pulled apart to get the &ldquo;upgraded&rdquo; transport back:</p>

<pre><code class="rust">.and_then(|(res, conn)| {
    // maybe get other headers from `res

    // Break up the HTTP connection into its parts
    let parts = conn.into_parts();
    let tcp = parts.io;
    // If the server sent the first message together with
    // the 101 response, it would be buffered here
    let buffered = parts.read_buf;

    // treat 'tcp' as a Websocket
})
</code></pre>

<p>The principle is the same with the server, just with accepting connections and responding with the 101 response instead.</p>

<p>This works with upgrading to any protocol, and even <code>CONNECT</code> requests. An easier API to do this with a <code>hyper::Client</code> or <code>hyper::Server</code> is still in exploration, but the building block are there for anyone to do it exactly as they see fit.</p>

<h2>Moving on towards 0.12</h2>

<p>This release is the last planned feature release for the 0.11.x branch of hyper. Progress towards the <a href="https://github.com/hyperium/hyper/milestone/4">0.12 feature set</a> is now underway! Here&rsquo;s a peak at some things that have already been accomplished on master:</p>

<ul>
<li>hyper has replaced its types with those from the <code>http</code> crate.</li>
<li>Replaced tokio-core usage with the new tokio crate (huge thanks to <a href="https://github.com/srijs">@srijs</a> for this and next point!).</li>
<li>Upgraded to futures 0.2.</li>
<li>Improvements to the <code>Connect</code> and <code>Body</code> APIs in preparation for better HTTP2 support.</li>
</ul>

<p>If you&rsquo;d like to join us in making this, take a peek at the <a href="https://github.com/hyperium/hyper/milestone/4">0.12 milestone</a>, or hop by the <a href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23hyper">#hyper IRC room</a>!</p>
